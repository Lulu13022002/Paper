From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 9 Sep 2018 13:30:00 -0400
Subject: [PATCH] Mob Pathfinding API

Implements Pathfinding API for mobs

diff --git a/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..da61f201bc1c47ac78d546c014506ef112b6e205
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
@@ -0,0 +1,189 @@
+package com.destroystokyo.paper.entity;
+
+import net.minecraft.world.level.pathfinder.BlockPathTypes;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Mob;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import net.minecraft.world.level.pathfinder.Node;
+import net.minecraft.world.level.pathfinder.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperPathfinder implements com.destroystokyo.paper.entity.Pathfinder {
+
+    private final net.minecraft.world.entity.Mob entity;
+
+    public PaperPathfinder(net.minecraft.world.entity.Mob entity) {
+        this.entity = entity;
+    }
+
+    @Override
+    public Mob getEntity() {
+        return entity.getBukkitMob();
+    }
+
+    @Override
+    public void stopPathfinding() {
+        entity.getNavigation().stop();
+    }
+
+    @Override
+    public boolean hasPath() {
+        return entity.getNavigation().getPath() != null;
+    }
+
+    @Nullable
+    @Override
+    public PathResult getCurrentPath() {
+        Path path = entity.getNavigation().getPath();
+        return path != null ? new PaperPathResult(path) : null;
+    }
+
+    @Nullable
+    @Override
+    public PathResult findPath(Location loc) {
+        Validate.notNull(loc, "Location can not be null");
+        Path path = entity.getNavigation().createPath(loc.getX(), loc.getY(), loc.getZ(), 0);
+        return path != null ? new PaperPathResult(path) : null;
+    }
+
+    @Nullable
+    @Override
+    public PathResult findPath(LivingEntity target) {
+        Validate.notNull(target, "Target can not be null");
+        Path path = entity.getNavigation().createPath(((CraftLivingEntity) target).getHandle(), 0);
+        return path != null ? new PaperPathResult(path) : null;
+    }
+
+    @Override
+    public boolean moveTo(@Nonnull PathResult path, double speed) {
+        Validate.notNull(path, "PathResult can not be null");
+        Path pathEntity = ((PaperPathResult) path).path;
+        return entity.getNavigation().moveTo(pathEntity, speed);
+    }
+
+    @Override
+    public boolean canOpenDoors() {
+        return entity.getNavigation().pathFinder.nodeEvaluator.canOpenDoors();
+    }
+
+    @Override
+    public void setCanOpenDoors(boolean canOpenDoors) {
+        entity.getNavigation().pathFinder.nodeEvaluator.setCanOpenDoors(canOpenDoors);
+    }
+
+    @Override
+    public boolean canPassDoors() {
+        return entity.getNavigation().pathFinder.nodeEvaluator.canPassDoors();
+    }
+
+    @Override
+    public void setCanPassDoors(boolean canPassDoors) {
+        entity.getNavigation().pathFinder.nodeEvaluator.setCanPassDoors(canPassDoors);
+    }
+
+    @Override
+    public boolean canFloat() {
+        return entity.getNavigation().pathFinder.nodeEvaluator.canFloat();
+    }
+
+    @Override
+    public void setCanFloat(boolean canFloat) {
+        entity.getNavigation().pathFinder.nodeEvaluator.setCanFloat(canFloat);
+    }
+
+    @Override
+    public void setPathInterestLevel(PathBlock pathBlock, float level) {
+        entity.setPathfindingMalus(BlockPathTypes.valueOf(pathBlock.name()), level);
+    }
+
+    @Override
+    public float getPathInterestLevel(PathBlock pathBlock) {
+        Validate.notNull(pathBlock, "Path block can not be null");
+        return entity.pathfindingMalus.get(BlockPathTypes.valueOf(pathBlock.name()));
+    }
+
+    @Override
+    public float getPathEffectiveInterestLevel(PathBlock pathBlock) {
+        Validate.notNull(pathBlock, "Path block can not be null");
+        return entity.getPathfindingMalus(BlockPathTypes.valueOf(pathBlock.name()));
+    }
+
+    @Override
+    public boolean inheritPathInterestForPassengers() {
+        return entity.shouldPassengersInheritMalusPaper();
+    }
+
+    @Override
+    public boolean canCutThroughCornerBlock(PathBlock pathBlock) {
+        Validate.notNull(pathBlock, "Path block can not be null");
+        return entity.canCutCorner(BlockPathTypes.valueOf(pathBlock.name()));
+    }
+
+    @Override
+    public List<PathBlock> getFearCutCornerBlocks() {
+        List<PathBlock> result = new ArrayList<>(entity.fearCornerBlocks.size());
+        for(BlockPathTypes block : entity.fearCornerBlocks) {
+            result.add(PathBlock.valueOf(block.name()));
+        }
+        return result;
+    }
+
+    @Override
+    public boolean addFearCutCornerBlock(PathBlock pathBlock) {
+        Validate.notNull(pathBlock, "Path block can not be null");
+        return entity.fearCornerBlocks.add(BlockPathTypes.valueOf(pathBlock.name()));
+    }
+
+    @Override
+    public boolean removeCutFearCornerBlock(PathBlock pathBlock) {
+        Validate.notNull(pathBlock, "Path block can not be null");
+        return entity.fearCornerBlocks.remove(BlockPathTypes.valueOf(pathBlock.name()));
+    }
+
+    public class PaperPathResult implements com.destroystokyo.paper.entity.PaperPathfinder.PathResult {
+
+        private final Path path;
+        PaperPathResult(Path path) {
+            this.path = path;
+        }
+
+        @Nullable
+        @Override
+        public Location getFinalPoint() {
+            Node point = path.getEndNode();
+            return point != null ? toLoc(point) : null;
+        }
+
+        @Override
+        public List<Location> getPoints() {
+            List<Location> points = new ArrayList<>();
+            for (Node point : path.nodes) {
+                points.add(toLoc(point));
+            }
+            return points;
+        }
+
+        @Override
+        public int getNextPointIndex() {
+            return path.getNextNodeIndex();
+        }
+
+        @Nullable
+        @Override
+        public Location getNextPoint() {
+            if (!path.hasNext()) {
+                return null;
+            }
+            return toLoc(path.nodes.get(path.getNextNodeIndex()));
+        }
+    }
+
+    private Location toLoc(Node point) {
+        return new Location(entity.level.getWorld(), point.x, point.y, point.z);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 2ffc99730c3d5dbdec63881a1eca07d5fbb1754e..dcd440a93f961650b782b58f4502ec6877d39d89 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -121,7 +121,7 @@ public abstract class Mob extends LivingEntity {
     public final float[] armorDropChances;
     private boolean canPickUpLoot;
     private boolean persistenceRequired;
-    private final Map<BlockPathTypes, Float> pathfindingMalus;
+    public final Map<BlockPathTypes, Float> pathfindingMalus; // Paper private -> public
     @Nullable
     public ResourceLocation lootTable;
     public long lootTableSeed;
@@ -132,6 +132,7 @@ public abstract class Mob extends LivingEntity {
     private CompoundTag leashInfoTag;
     private BlockPos restrictCenter;
     private float restrictRadius;
+    public List<BlockPathTypes> fearCornerBlocks = new java.util.ArrayList<>(); // Paper
 
     public boolean aware = true; // CraftBukkit
 
@@ -156,6 +157,7 @@ public abstract class Mob extends LivingEntity {
         Arrays.fill(this.handDropChances, 0.085F);
         if (world != null && !world.isClientSide) {
             this.registerGoals();
+            this.registerFearCornerBlocks(); // Paper
         }
 
     }
@@ -167,6 +169,14 @@ public abstract class Mob extends LivingEntity {
     // CraftBukkit end
 
     protected void registerGoals() {}
+    // Paper start - Pathfinding API
+    protected void registerFearCornerBlocks() {
+        fearCornerBlocks.add(BlockPathTypes.DANGER_FIRE);
+        fearCornerBlocks.add(BlockPathTypes.DANGER_CACTUS);
+        fearCornerBlocks.add(BlockPathTypes.DANGER_OTHER);
+        fearCornerBlocks.add(BlockPathTypes.WALKABLE_DOOR);
+    }
+    // Paper end
 
     public static AttributeSupplier.Builder createMobAttributes() {
         return LivingEntity.createLivingAttributes().add(Attributes.FOLLOW_RANGE, 16.0D).add(Attributes.ATTACK_KNOCKBACK);
@@ -179,6 +189,11 @@ public abstract class Mob extends LivingEntity {
     protected boolean shouldPassengersInheritMalus() {
         return false;
     }
+    // Paper start - Pathfinding API
+    public boolean shouldPassengersInheritMalusPaper() {
+        return shouldPassengersInheritMalus();
+    }
+    // Paper end
 
     public float getPathfindingMalus(BlockPathTypes nodeType) {
         Mob entityinsentient;
@@ -199,7 +214,7 @@ public abstract class Mob extends LivingEntity {
     }
 
     public boolean canCutCorner(BlockPathTypes type) {
-        return type != BlockPathTypes.DANGER_FIRE && type != BlockPathTypes.DANGER_CACTUS && type != BlockPathTypes.DANGER_OTHER && type != BlockPathTypes.WALKABLE_DOOR;
+        return !fearCornerBlocks.contains(type); // Paper pathfinding API
     }
 
     protected BodyRotationControl createBodyControl() {
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
index 01f8d11ee4441a1c4d87427e3f9bcd7155259a5b..e59ab91c978670c9698d934cf8c5c63711ebb025 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
@@ -92,6 +92,12 @@ public class Frog extends Animal {
         this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
         this.maxUpStep = 1.0F;
     }
+    // Paper start - Pathfinding API
+    @Override
+    protected void registerFearCornerBlocks() {
+        fearCornerBlocks.add(BlockPathTypes.WATER_BORDER);
+    }
+    // Paper end
 
     @Override
     protected Brain.Provider<Frog> brainProvider() {
@@ -351,7 +357,7 @@ public class Frog extends Animal {
 
     @Override
     public boolean canCutCorner(BlockPathTypes type) {
-        return super.canCutCorner(type) && type != BlockPathTypes.WATER_BORDER;
+        return super.canCutCorner(type); // Paper - Pathfinding API
     }
 
     public static boolean canEat(LivingEntity entity) {
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/Path.java b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
index 4ad2ac8d1e9111933fa58c47442fa1f5e8173fd3..2a335f277bd0e4b8ad0f60d8226eb8aaa80a871f 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/Path.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
@@ -21,6 +21,7 @@ public class Path {
     private final BlockPos target;
     private final float distToTarget;
     private final boolean reached;
+    public boolean hasNext() { return getNextNodeIndex() < this.nodes.size(); } // Paper
 
     public Path(List<Node> nodes, BlockPos target, boolean reachesTarget) {
         this.nodes = nodes;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMob.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMob.java
index 55c27a3d9b540c4c4d7701bd0cdf167bb7af3dd4..28d6e31bfdf31d3e56024c731b833c4424313307 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMob.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMob.java
@@ -12,8 +12,11 @@ import org.bukkit.loot.LootTable;
 public abstract class CraftMob extends CraftLivingEntity implements Mob {
     public CraftMob(CraftServer server, net.minecraft.world.entity.Mob entity) {
         super(server, entity);
+         paperPathfinder = new com.destroystokyo.paper.entity.PaperPathfinder(entity); // Paper
     }
 
+    private final com.destroystokyo.paper.entity.PaperPathfinder paperPathfinder; // Paper
+    @Override public com.destroystokyo.paper.entity.Pathfinder getPathfinder() { return paperPathfinder; } // Paper
     @Override
     public void setTarget(LivingEntity target) {
         Preconditions.checkState(!this.getHandle().generation, "Cannot set target during world generation");
